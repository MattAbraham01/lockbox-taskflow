"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "../fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "../fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "../fhevm/GenericStringStorage";

// Activity types enum
export enum ActivityType {
  Running = 0,
  Cycling = 1,
  Swimming = 2,
  Weightlifting = 3,
  Yoga = 4,
  Walking = 5,
}

// Activity type labels and icons
export const ACTIVITY_TYPES = [
  { type: ActivityType.Running, label: "ðŸƒ Running", unit: "minutes", color: "from-blue-500 to-cyan-500" },
  { type: ActivityType.Cycling, label: "ðŸš´ Cycling", unit: "minutes", color: "from-green-500 to-emerald-500" },
  { type: ActivityType.Swimming, label: "ðŸŠ Swimming", unit: "minutes", color: "from-blue-600 to-indigo-600" },
  { type: ActivityType.Weightlifting, label: "ðŸ‹ï¸ Weightlifting", unit: "minutes", color: "from-red-500 to-pink-500" },
  { type: ActivityType.Yoga, label: "ðŸ§˜ Yoga", unit: "minutes", color: "from-purple-500 to-violet-500" },
  { type: ActivityType.Walking, label: "ðŸš¶ Walking", unit: "minutes", color: "from-yellow-500 to-orange-500" },
];

// Simple logger for development
const isDev = process.env.NODE_ENV === 'development';
const logger = {
  debug: (message: string, ...args: any[]) => {
    if (isDev) {
      console.log(`[DEBUG] ${message}`, ...args);
    }
  }
};

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/packages/lock-box/deployments directory to retrieve
  deployment information for EncryptedFitnessTracker.sol:

  - <root>/packages/site/abi/abi/EncryptedFitnessTrackerABI.ts
  - <root>/packages/site/abi/abi/EncryptedFitnessTrackerAddresses.ts
*/
import { EncryptedFitnessTrackerAddresses } from "../abi/EncryptedFitnessTrackerAddresses";
import { EncryptedFitnessTrackerABI } from "../abi/EncryptedFitnessTrackerABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};
type EncryptedFitnessTrackerInfoType = {
  abi: typeof EncryptedFitnessTrackerABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves EncryptedFitnessTracker contract metadata for the given EVM `chainId`.
 */
function getEncryptedFitnessTrackerByChainId(
  chainId: number | undefined
): EncryptedFitnessTrackerInfoType {
  if (!chainId) {
    return { abi: EncryptedFitnessTrackerABI.abi };
  }

  const entry =
    EncryptedFitnessTrackerAddresses[chainId.toString() as keyof typeof EncryptedFitnessTrackerAddresses];

  // For localhost development (chainId 31337), we always return valid config
  // even if the address is zero (contract will be deployed at runtime)
  if (chainId === 31337) {
    return {
      address: entry?.address as `0x${string}` | undefined,
      chainId: entry?.chainId ?? chainId,
      chainName: entry?.chainName,
      abi: EncryptedFitnessTrackerABI.abi,
    };
  }

  // For other networks, check if deployment exists
  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    console.warn(`EncryptedFitnessTracker: Unsupported chainId ${chainId}. Only localhost (31337) is supported for this demo.`);
    return { abi: EncryptedFitnessTrackerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: EncryptedFitnessTrackerABI.abi,
  };
}

export const useEncryptedFitnessTracker = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [activityHandles, setActivityHandles] = useState<Record<ActivityType, string | undefined>>({
    [ActivityType.Running]: undefined,
    [ActivityType.Cycling]: undefined,
    [ActivityType.Swimming]: undefined,
    [ActivityType.Weightlifting]: undefined,
    [ActivityType.Yoga]: undefined,
    [ActivityType.Walking]: undefined,
  });
  const [totalActivities, setTotalActivities] = useState<number | undefined>(undefined);
  const [lastUpdateTime, setLastUpdateTime] = useState<number | undefined>(undefined);
  const [clearActivityData, setClearActivityData] = useState<Record<ActivityType, ClearValueType | undefined>>({
    [ActivityType.Running]: undefined,
    [ActivityType.Cycling]: undefined,
    [ActivityType.Swimming]: undefined,
    [ActivityType.Weightlifting]: undefined,
    [ActivityType.Yoga]: undefined,
    [ActivityType.Walking]: undefined,
  });

  const clearActivityDataRef = useRef<Record<ActivityType, ClearValueType | undefined>>({
    [ActivityType.Running]: undefined,
    [ActivityType.Cycling]: undefined,
    [ActivityType.Swimming]: undefined,
    [ActivityType.Weightlifting]: undefined,
    [ActivityType.Yoga]: undefined,
    [ActivityType.Walking]: undefined,
  });

  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<Record<ActivityType, boolean>>({
    [ActivityType.Running]: false,
    [ActivityType.Cycling]: false,
    [ActivityType.Swimming]: false,
    [ActivityType.Weightlifting]: false,
    [ActivityType.Yoga]: false,
    [ActivityType.Walking]: false,
  });
  const [isStoring, setIsStoring] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const fitnessTrackerRef = useRef<EncryptedFitnessTrackerInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<Record<ActivityType, boolean>>(isDecrypting);
  const isStoringRef = useRef<boolean>(isStoring);

  const fitnessTracker = useMemo(() => {
    const c = getEncryptedFitnessTrackerByChainId(chainId);

    fitnessTrackerRef.current = c;

    if (!c.address) {
      setMessage(`EncryptedFitnessTracker deployment not found for chainId=${chainId}.`);
    } else if (chainId !== undefined) {
      setMessage("");
    }

    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!fitnessTracker) {
      return undefined;
    }
    return (Boolean(fitnessTracker.address) && fitnessTracker.address !== ethers.ZeroAddress);
  }, [fitnessTracker]);

  const canGetFitnessData = useMemo(() => {
    return fitnessTracker.address && ethersReadonlyProvider && !isRefreshing;
  }, [fitnessTracker.address, ethersReadonlyProvider, isRefreshing]);

  const refreshFitnessData = useCallback(() => {
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !fitnessTrackerRef.current ||
      !fitnessTrackerRef.current?.chainId ||
      !fitnessTrackerRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setActivityHandles({
        [ActivityType.Running]: undefined,
        [ActivityType.Cycling]: undefined,
        [ActivityType.Swimming]: undefined,
        [ActivityType.Weightlifting]: undefined,
        [ActivityType.Yoga]: undefined,
        [ActivityType.Walking]: undefined,
      });
      setTotalActivities(undefined);
      setLastUpdateTime(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = fitnessTrackerRef.current.chainId;
    const thisFitnessTrackerAddress = fitnessTrackerRef.current.address;

    const thisFitnessTrackerContract = new ethers.Contract(
      thisFitnessTrackerAddress,
      fitnessTrackerRef.current.abi,
      ethersReadonlyProvider
    );

    console.log(`[refreshFitnessData] Calling contract methods on address: ${thisFitnessTrackerAddress}`);

    const getUserAddressAndCall = async () => {
      const userAddress = ethersSigner ? await ethersSigner.getAddress() : "0x0000000000000000000000000000000000000000";
      console.log(`[refreshFitnessData] Using user address: ${userAddress}`);

      // Get data for all activity types
      const promises = ACTIVITY_TYPES.map(activity =>
        thisFitnessTrackerContract.getActivityData(userAddress, activity.type)
      );

      return Promise.all([
        ...promises,
        thisFitnessTrackerContract.getTotalActivities(userAddress),
        thisFitnessTrackerContract.getLastUpdateTime(userAddress),
      ]);
    };

    getUserAddressAndCall()
      .then((results) => {
        const activityResults = results.slice(0, ACTIVITY_TYPES.length);
        const [totalActivitiesResult, updateTime] = results.slice(ACTIVITY_TYPES.length);

        console.log("[refreshFitnessData] Activity data:", activityResults);
        console.log("[refreshFitnessData] Total activities:", totalActivitiesResult);
        console.log("[refreshFitnessData] Last update time:", updateTime);

        if (
          sameChain.current(thisChainId) &&
          thisFitnessTrackerAddress === fitnessTrackerRef.current?.address
        ) {
          const newHandles: Record<ActivityType, string | undefined> = {
            [ActivityType.Running]: undefined,
            [ActivityType.Cycling]: undefined,
            [ActivityType.Swimming]: undefined,
            [ActivityType.Weightlifting]: undefined,
            [ActivityType.Yoga]: undefined,
            [ActivityType.Walking]: undefined,
          };

          ACTIVITY_TYPES.forEach((activity, index) => {
            const handle = activityResults[index];
            newHandles[activity.type] = handle ? handle.toString() : "0";
          });

          setActivityHandles(newHandles);
          setTotalActivities(Number(totalActivitiesResult));
          setLastUpdateTime(Number(updateTime));
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("EncryptedFitnessTracker.getActivityData() call failed! error=" + e);

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain, ethersSigner]);

  useEffect(() => {
    refreshFitnessData();
  }, [ethersReadonlyProvider, fitnessTracker.address, refreshFitnessData]);

  const canDecryptActivity = useCallback((activityType: ActivityType) => {
    const hasAddress = !!fitnessTracker.address;
    const hasInstance = !!instance;
    const hasSigner = !!ethersSigner;
    const notRefreshing = !isRefreshing;
    const notDecrypting = !isDecrypting[activityType];
    const handle = activityHandles[activityType];
    const hasValue = handle && handle !== "0" && handle !== ethers.ZeroHash;
    const clearData = clearActivityData[activityType];
    const notAlreadyDecrypted = !clearData || clearData.clear !== handle;

    return Boolean(
      hasAddress &&
      hasInstance &&
      hasSigner &&
      notRefreshing &&
      notDecrypting &&
      hasValue &&
      notAlreadyDecrypted
    );
  }, [fitnessTracker.address, instance, ethersSigner, isRefreshing, isDecrypting, activityHandles, clearActivityData]);

  const isActivityDecrypted = useCallback((activityType: ActivityType) => {
    const handle = activityHandles[activityType];
    const clearData = clearActivityData[activityType];
    return handle && handle === clearData?.handle;
  }, [activityHandles, clearActivityData]);

  const canStoreActivityData = useMemo(() => {
    return (
      fitnessTracker.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isStoring
    );
  }, [fitnessTracker.address, instance, ethersSigner, isRefreshing, isStoring]);

  const storeActivityData = useCallback((activityType: ActivityType, activityDataMinutes: number) => {
    if (isRefreshingRef.current || isStoringRef.current) {
      return;
    }

    if (!fitnessTracker.address || !instance || !ethersSigner) {
      return;
    }

    const thisChainId = chainId;
    const thisFitnessTrackerAddress = fitnessTracker.address;
    const thisEthersSigner = ethersSigner;
    const thisFitnessTrackerContract = new ethers.Contract(
      thisFitnessTrackerAddress,
      fitnessTracker.abi,
      thisEthersSigner
    );

    const activityName = ACTIVITY_TYPES.find(a => a.type === activityType)?.label || "Unknown";
    const opMsg = `storeActivityData(${activityName}, ${activityDataMinutes} minutes)`;

    isStoringRef.current = true;
    setIsStoring(true);
    setMessage(`Start ${opMsg}...`);

    const run = async () => {
      await new Promise((resolve) => setTimeout(resolve, 100));

      const isStale = () =>
        thisFitnessTrackerAddress !== fitnessTrackerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        console.log(`[storeActivityData] Simplified version: calling contract directly with plain value`);

        if (isStale()) {
          setMessage(`Ignore ${opMsg}`);
          return;
        }

        setMessage(`Call ${opMsg}...`);

        console.log(`[storeActivityData] Calling contract.storeActivityData with type: ${activityType}, value: ${activityDataMinutes}`);

        const tx: ethers.TransactionResponse =
          await thisFitnessTrackerContract.storeActivityData(
            activityType,
            activityDataMinutes,
            "0x00"
          );

        console.log(`[storeActivityData] Transaction sent, hash: ${tx.hash}`);
        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();

        console.log(`[storeActivityData] Transaction mined, status: ${receipt?.status}, gas used: ${receipt?.gasUsed}`);
        setMessage(`Call ${opMsg} completed status=${receipt?.status}`);

        if (isStale()) {
          setMessage(`Ignore ${opMsg}`);
          return;
        }

        setTimeout(() => {
          console.log(`[storeActivityData] Calling refreshFitnessData after 3 second delay`);
          refreshFitnessData();
        }, 3000);
      } catch (e) {
        setMessage(`${opMsg} Failed! Error: ${e}`);
      } finally {
        isStoringRef.current = false;
        setIsStoring(false);
      }
    };

    run();
  }, [
    ethersSigner,
    fitnessTracker.address,
    fitnessTracker.abi,
    instance,
    chainId,
    refreshFitnessData,
    sameChain,
    sameSigner,
  ]);

  const decryptActivityData = useCallback((activityType: ActivityType) => {
    if (isRefreshingRef.current || isDecryptingRef.current[activityType]) {
      return;
    }

    if (!fitnessTracker.address || !instance || !ethersSigner) {
      return;
    }

    const handle = activityHandles[activityType];
    if (handle === clearActivityDataRef.current[activityType]?.handle) {
      return;
    }

    if (!handle) {
      setClearActivityData(prev => ({
        ...prev,
        [activityType]: undefined
      }));
      clearActivityDataRef.current[activityType] = undefined;
      return;
    }

    if (handle === ethers.ZeroHash) {
      setClearActivityData(prev => ({
        ...prev,
        [activityType]: { handle, clear: BigInt(0) }
      }));
      clearActivityDataRef.current[activityType] = { handle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisFitnessTrackerAddress = fitnessTracker.address;
    const thisHandle = handle;
    const thisEthersSigner = ethersSigner;

    setIsDecrypting(prev => ({ ...prev, [activityType]: true }));

    setMessage("Requesting decryption authorization from contract...");

    const run = async () => {
      const isStale = () =>
        thisFitnessTrackerAddress !== fitnessTrackerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        if (!fitnessTrackerRef.current) {
          setMessage("Contract reference not available");
          return;
        }

        const contract = new ethers.Contract(
          thisFitnessTrackerAddress,
          fitnessTrackerRef.current.abi,
          thisEthersSigner
        );

        const requestId = Date.now();

        const activityName = ACTIVITY_TYPES.find(a => a.type === activityType)?.label || "Unknown";
        setMessage(`Calling requestDecryptActivityData(${activityName}, ${requestId}) - please confirm in MetaMask...`);

        const txResponse = await contract.requestDecryptActivityData(activityType, requestId);

        console.log('[decryptActivityData] Waiting for transaction confirmation...');
        const txReceipt = await txResponse.wait();
        console.log('[decryptActivityData] Transaction confirmed, receipt:', txReceipt);

        const plainValue = await contract.getActivityData(ethersSigner.address, activityType);
        console.log('[decryptActivityData] Got plain value from getActivityData:', plainValue, typeof plainValue);

        let clearValue;
        if (typeof plainValue === 'number' || typeof plainValue === 'bigint') {
          clearValue = BigInt(plainValue);
        } else if (typeof plainValue === 'string') {
          clearValue = BigInt(plainValue);
        } else if (plainValue && typeof plainValue === 'object' && 'toString' in plainValue) {
          clearValue = BigInt(plainValue.toString());
        } else {
          console.error('[decryptActivityData] Unexpected plainValue format:', plainValue, typeof plainValue);
          throw new Error('Unexpected plainValue format from contract call');
        }

        setMessage(`Decryption completed! ${activityName}: ${clearValue} minutes`);

        if (isStale()) {
          setMessage("Ignore decryption result");
          return;
        }

        const newClearData = { handle: thisHandle, clear: clearValue };
        setClearActivityData(prev => ({
          ...prev,
          [activityType]: newClearData
        }));
        clearActivityDataRef.current[activityType] = newClearData;

        setMessage(
          `${activityName} clear value is ${clearActivityDataRef.current[activityType].clear} minutes`
        );
      } finally {
        setIsDecrypting(prev => ({ ...prev, [activityType]: false }));
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    fitnessTracker.address,
    instance,
    activityHandles,
    chainId,
    sameChain,
    sameSigner,
    setIsDecrypting,
  ]);


  return {
    contractAddress: fitnessTracker.address,
    canDecryptActivity,
    canGetFitnessData,
    canStoreActivityData,
    storeActivityData,
    decryptActivityData,
    refreshFitnessData,
    isActivityDecrypted,
    message,
    clearActivityData,
    activityHandles,
    totalActivities,
    lastUpdateTime,
    isDecrypting,
    isRefreshing,
    isStoring,
    isDeployed,
    ACTIVITY_TYPES,
  };
};

